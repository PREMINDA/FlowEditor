
import {
    Logger, logger,
    LoggingDebugSession,
    InitializedEvent, TerminatedEvent, StoppedEvent, OutputEvent,
    Thread, Scope, Variable
} from 'vscode-debugadapter';
import type { DebugProtocol } from 'vscode-debugprotocol';
import * as child_process from 'child_process';

/**
 * Interface that describes the specific arguments valid for the 'launch' request.
 */
interface ILaunchRequestArguments extends DebugProtocol.LaunchRequestArguments {
    /** An absolute path to the "program" to debug. */
    program: string;
    /** Automatically stop target after launch. If not specified, target does not stop. */
    stopOnEntry?: boolean;
    /** enable logging the Debug Adapter Protocol */
    trace?: boolean;
    /** Java specific configs could go here (e.g. mainClass, projectName, vmArgs) */
    mainClass?: string;
    projectName?: string;
}

export class FlowDebugSession extends LoggingDebugSession {

    // We'll use a single "thread" for the flow execution
    private static THREAD_ID = 1;

    // The Java child process
    private _javaProcess: child_process.ChildProcess | undefined;

    // Buffer to handle partial output lines
    private _outputBuffer = '';

    private _breakpoints = new Set<string>();

    // Store variables from the last pause event
    private _variableHandles = new Map<number, any>();
    private _variableScopeStartHandle = 1000;

    public constructor() {
        super("flow-debug.txt");

        // this debugger uses zero-based lines and columns
        this.setDebuggerLinesStartAt1(false);
        this.setDebuggerColumnsStartAt1(false);
    }

    /**
     * The 'initialize' request is the first request called by the frontend
     * to interrogate the capability of the debug adapter.
     */
    protected initializeRequest(response: DebugProtocol.InitializeResponse, _args: DebugProtocol.InitializeRequestArguments): void {

        // build and return the capabilities of this debug adapter:
        response.body = response.body || {};

        // the adapter implements the configurationDoneRequest.
        response.body.supportsConfigurationDoneRequest = true;

        // make VS Code use 'evaluate' when hovering over source
        response.body.supportsEvaluateForHovers = false; // Set true if we implement variable evaluation later

        // make VS Code support the 'step' (next) button
        response.body.supportsStepBack = false;
        response.body.supportsRestartRequest = false;

        this.sendResponse(response);

        // since this debug adapter can accept configurationDoneRequests, we have to tell the frontend that we are ready to accept configurationDoneRequests.
        this.sendEvent(new InitializedEvent());
    }

    /**
     * Called when VS Code wants to set breakpoints in a file.
     * Since we are using "Node IDs" via custom requests, we just acknowledge this to keep VS Code happy.
     */
    protected setBreakpointsRequest(response: DebugProtocol.SetBreakpointsResponse, args: DebugProtocol.SetBreakpointsArguments): void {
        // Just verify all breakpoints so they show as "active" (red circle) in the text file if user sets one there
        const actualBreakpoints = (args.breakpoints || []).map(bp => ({
            verified: true,
            line: bp.line
        }));

        response.body = {
            breakpoints: actualBreakpoints
        };
        this.sendResponse(response);
    }

    /**
     * The 'configurationDone' request is called after the frontend has finished setting up breakpoints.
     * We don't need to do much here unless we have buffered breakpoints.
     */
    protected configurationDoneRequest(response: DebugProtocol.ConfigurationDoneResponse, args: DebugProtocol.ConfigurationDoneArguments): void {
        super.configurationDoneRequest(response, args);
    }

    /**
     * Start the execution of the debugged program.
     */
    protected async launchRequest(response: DebugProtocol.LaunchResponse, args: ILaunchRequestArguments): Promise<void> {

        // 1. Setup logging
        logger.setup(Logger.LogLevel.Verbose, false);

        // 2. Prepare the Java Command
        // In a real scenario, we would construct this from 'args' (main class, classpath, etc.)
        // For this template, we assume the user provides a 'program' pointing to their runner jar or class.

        const _program = args.program; // e.g., "target/classes" or "my-runner.jar"
        const mainClass = args.mainClass || "com.example.FlowRunner";

        // Example command: java -cp target/classes com.example.FlowRunner
        const command = 'java';
        const commandArgs = ['-cp', '.', mainClass]; // SIMPLIFIED for demo

        // 3. Spawn the Process
        this._javaProcess = child_process.spawn(command, commandArgs, {
            cwd: UserWorkspaceOrRoot // You'd resolve this properly from extension context usually
        });

        if (!this._javaProcess.pid) {
            this.sendErrorResponse(response, {
                id: 1001,
                format: "Failed to start Java process."
            });
            return;
        }

        // 4. Listen to Output (Events)
        this._javaProcess.stdout?.on('data', (data: any) => this.handleStdout(data));
        this._javaProcess.stderr?.on('data', (data: any) => this.handleStderr(data));

        this._javaProcess.on('close', (_code: any) => {
            this.sendEvent(new TerminatedEvent());
        });

        this.sendResponse(response);
    }

    /**
     * Handle Standard Output from Java
     * Detects "@@FLOW:PAUSED:node-1" events
     */
    private handleStdout(data: Buffer | string) {
        const text = data.toString();
        this._outputBuffer += text;

        const lines = this._outputBuffer.split('\n');
        // Keep the last partial line in buffer
        this._outputBuffer = lines.pop() || '';

        for (const line of lines) {
            const trimmed = line.trim();

            // HERE IS THE MAGIC CHECK
            if (trimmed.startsWith("@@FLOW:PAUSED:")) {

                // Format: @@FLOW:PAUSED:node-1:{ "var1": "val1" }
                // Use a regex or robust split to handle the JSON part which might contain colons
                const firstColon = trimmed.indexOf(':');
                const secondColon = trimmed.indexOf(':', firstColon + 1);
                const thirdColon = trimmed.indexOf(':', secondColon + 1);

                let nodeId = '';
                let variablesJson = '{}';

                if (thirdColon > -1) {
                    nodeId = trimmed.substring(secondColon + 1, thirdColon);
                    variablesJson = trimmed.substring(thirdColon + 1);
                } else {
                    // Fallback for old format without vars
                    nodeId = trimmed.substring(secondColon + 1);
                }

                // Parse and Store Variables
                try {
                    const vars = JSON.parse(variablesJson);
                    this._variableHandles.clear();
                    this._variableHandles.set(this._variableScopeStartHandle, vars);
                } catch (e) {
                    this.sendEvent(new OutputEvent(`[FLOW] Failed to parse variables: ${e}\n`, 'stderr'));
                }

                // CHECK: Should we actually stop?
                if (this._breakpoints.has(nodeId)) {
                    // YES -> Stop and wait for user
                    this.sendEvent(new StoppedEvent('breakpoint', FlowDebugSession.THREAD_ID));
                    this.sendEvent(new OutputEvent(`[FLOW] Paused at ${nodeId}\n`, 'stdout'));
                } else {
                    // NO -> Auto-Resume immediately
                    this.sendCommand("RESUME");
                    // Optional: Trace log if you want to see flow without stopping
                    // this.sendEvent(new OutputEvent(`[FLOW] Trace ${nodeId}\n`, 'stdout'));
                }

            } else {  // Normal output
                this.sendEvent(new OutputEvent(line + '\n', 'stdout'));
            }
        }
    }

    private handleStderr(data: Buffer | string) {
        this.sendEvent(new OutputEvent(data.toString(), 'stderr'));
    }

    // --- Control Commands ---

    protected continueRequest(response: DebugProtocol.ContinueResponse, _args: DebugProtocol.ContinueArguments): void {
        this.sendCommand("RESUME");
        this.sendResponse(response);
    }

    protected nextRequest(response: DebugProtocol.NextResponse, _args: DebugProtocol.NextArguments): void {
        this.sendCommand("STEP");
        this.sendResponse(response);
    }

    protected disconnectRequest(response: DebugProtocol.DisconnectResponse, _args: DebugProtocol.DisconnectArguments, _request?: DebugProtocol.Request): void {
        // Kill the Java process
        if (this._javaProcess) {
            this._javaProcess.kill();
        }
        this.sendResponse(response);
    }

    /**
     * Handle custom requests from the extension.
     * This is how we support 'Node ID' breakpoints instead of Line Numbers.
     */
    protected customRequest(command: string, response: DebugProtocol.Response, args: any): void {
        if (command === 'updateNodeBreakpoints') {
            const nodeIds = args.nodeIds as string[];
            if (nodeIds) {
                // Update internal list
                this._breakpoints.clear();
                nodeIds.forEach(id => this._breakpoints.add(id));
            }
            this.sendResponse(response);
        } else {
            super.customRequest(command, response, args);
        }
    }

    /**
     * Send command to Java process via Stdin
     */
    private sendCommand(cmd: string) {
        if (this._javaProcess && this._javaProcess.stdin) {
            this._javaProcess.stdin.write(cmd + "\n");
        }
    }

    // --- Threads (Minimal) ---
    protected threadsRequest(response: DebugProtocol.ThreadsResponse): void {
        response.body = {
            threads: [
                new Thread(FlowDebugSession.THREAD_ID, "Flow Execution")
            ]
        };
        this.sendResponse(response);
    }

    // --- Variables Support ---

    protected scopesRequest(response: DebugProtocol.ScopesResponse, _args: DebugProtocol.ScopesArguments): void {
        response.body = {
            scopes: [
                new Scope("Flow Variables", this._variableScopeStartHandle, false)
            ]
        };
        this.sendResponse(response);
    }

    protected variablesRequest(response: DebugProtocol.VariablesResponse, args: DebugProtocol.VariablesArguments): void {
        const variables: Variable[] = [];
        const handle = args.variablesReference;

        const data = this._variableHandles.get(handle);

        if (data) {
            for (const key of Object.keys(data)) {
                const value = data[key];
                // Simple implementation: assume all values are strings/numbers for now
                // Complex objects would need recursive handles
                variables.push({
                    name: key,
                    value: String(value),
                    variablesReference: 0
                });
            }
        }

        response.body = {
            variables: variables
        };
        this.sendResponse(response);
    }
}

// Temporary placeholder for CWD resolution
const UserWorkspaceOrRoot = ".";
